# 프로세스 관리

## 프로세스란?

프로세스는 실행 중인 프로그램이다. 프로그램이 메인 메모리에 적재(loading)되어 있을 떄 프로세스라고 부른다.



![프로세스 상태 전이표](https://raw.githubusercontent.com/Crazy0416/Study_Summery/master/OS/resources/process_manage_1.png)

### 프로세스 5가지 상태

- new: 프로그램이 메인 메모리에 올라오는 상태
- ready: CPU 할당 받는 것을 기다리는 상태
- running: CPU가 할당되어 작업을 수행 중인 상태
- waiting: I/O와 같은 CPU 외의 할당을 받아 기다리는 상태
- terminated: 모든 작업이 끝나 프로세스가 종료된 상태



#### I/O 작업이나 기타 이벤트로 인한 상태 변화

Running -> Waiting -> Ready -> Running

#### 시간에 의한 Interrupt

Running -> Ready -> Running





### 프로세스 대기 큐, 스케줄러 3가지

#### Job Queue, Long-term Scheduler

**프로세스가 되기 전**에 **메인 메모리**에 올라갈 자리가 없다면 **대기**해야 하는데 이 대기열을 **Job Queue**라고 한다. **메모리에 어떤 것들을 올릴지 결정**하는 스케줄러는 **Job Scheduler**이며 **Job Queue를 관리**합니다. 오래 기다려야 하기 때문에 Job Scheduler는 **Long-term Scheduler**라고도 불린다.



#### Ready Queue, Short-term Scheduler

**메모리에 있는 프로세스**가 **CPU 할당**을 받기 위해 기다리고 있는 **대기열**을 **Ready Queue**라고 한다. **어떤 프로세스에게 CPU 자원을 할당할 것인지 결정**하는 스케줄러는 **CPU Scheduler**이며 **Ready Queue**를 관리합니다. 위의 Job Scheduler와 달리 대기 시간이 짧기 때문에 **Short-term scheduler**라고 불린다.



#### Device Queue, Device Scheduler

**하드 디스크**나 **I/O의 할당**을 받기 위해서 프로세스는 **대기열**에서 기다리는데 그 때는 **Device Queue**를 이용한다. **Device scheduler**에 의해 제어된다.



이 모든 스케줄러는 운영체제에 존재하며 각 Queues의 순서를 관리하는 역할을 한다.



## MultiProgramming (다중 프로그래밍)

한번에 여러개의 프로그램을 동시에 메인 메모리에 적재하여 실행함으로 CPU 연산과 처리를 중첩시켜 CPU 유휴시간을 감소한다.



#### PCB (Process Control Block)

PCB란 프로세스의 정보를 저장하고 있는 자료구조로 각 프로세스마다 하나씩 생성됩니다. PID, 프로세스의 상태(5가지 상태), Program Counter, Register 등을 저장하고 있습니다. 

- PID: 프로세스 식별자
- Program Counter: 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.

프로세스가 시간이 지나거나 인터럽트 혹은 시스템콜이 호출되면 **잠시 대기**해야 한다. 그 뒤 이전의 작업들을 잃지 않고 **다시 실행**하려면 **프로그램에 대한 정보**들을 다시 불러와야 한다. 이 때 **정보들을 저장할 자료구조**가 **PCB**이다.



#### Context Switching (문맥 전환)

현재 동작하고 있는 **프로세스의 실행 정보(PCB의 정보)**들을 **저장**하고 **다른 프로세스의 실행 정보**를 **적재**하는 것을 의미한다. CPU를 프로세스끼리 나눠쓰기 위함이다.

여기서 **Scheduler(스케줄러)**는 어떤 프로세스가 실행되야할 지 결정하고 **Dispatcher(디스패처)**는 그에 대한 실행, 할당을 수행한다.



## 스케줄링

### 두 가지의 CPU 스케줄링

#### 선점 방식(Preemptive)

하나의 프로세스가 CPU를 할당받아 작업을 수행하고 있는 도중에 다른 프로세스가 새치기 할 수 있는 방식

#### 비선점 방식(Non-Preemptive)

하나의 프로세스가 CPU 할당이 끝나야 다른 프로세스가 CPU를 할당 받을 수 있는 방식



### CPU 스케줄링 알고리즘

#### FCFS (First Come First Served)

**먼저 들어온 프로세스를 먼저 실행하는 알고리즘**. 가장 간단하고 공정한 알고리즘이지만 평균 대기시간이 긴 편이다.



#### Short Job First 

**가장 짧은 CPU 할당 시간을 가진 프로세스를 먼저 처리하는 방식**. 평균 대기시간이 짧지만 CPU 할당시간을 정확하게 모르므로 예측을 통해 진행해야 한다.

선점, 비선점 방식으로 동작 가능하다.



#### Priority Scheduling

**우선순위 스케줄링이 높은 작업들을 먼저 수행하는 알고리즘.**

선점, 비선점 방식으로 수행 가능하다.

만약 우선 순위가 밀리고 계속해서 높은 우선순위의 작업이 들어온다면 그 밀린 작업은 Starvation 상태가 된다.

이를 해결하기 위해 Aging이라는 방법이 잇는데 오랜 시간 기다린 작업의 우선순위를 일정 비율만큼 올려 문제를 해결한다.



#### Round Robin Scheduling

time quantum을 할당하는 알고리즘으로 선점 방식으로만 구현 가능.

**일정 시간을 선정하여 CPU 할당을 모든 프로세스에게 동일하게 분담하는 방식**이다.



#### Multilevel Queue Scheduling

**프로세스의 종류에 따라 다른 level을 두어 스케줄링하는 방식**

시스템 프로세스, interactive process, interactive editing process 등으로 프로세스 그룹을 나누게 된다. Queue를 여러개 두어 각 Queue마다 처리하는 프로세스를 다르게 처리한다.



## Thread

### Thread 쓰레드

하나의 프로그램 내부의 여러 개의 실행 흐름을 위한 모델이다.



### 메모리 공간에서의 쓰레드

쓰레드는 **프로세스의** **Heap, Stack, Code, Data** 영역 중 **Stack을 제외**한 부분을 서로 **공유**한다. 즉 쓰레드마다 자신만의 Stack을 할당받는다.

또한 **나머지 메모리 영역을 공유**하므로 **데이터를 서로 공유할 수 있는 장점**이 있다. 또한 메모리를 공유하기 때문에 **쓰레드 Context Switching**이 일어날 때 **Process의 그것보다 시간과 자원을 할당하는 것이 덜 소모**된다.

하지만 **임계 영역 (Critical Section)**에서 **데이터의 일관성 문제**, 혹은 **데드락 문제**가 발생할 수 있다.



### Multi Thread Model

#### 두 가지 Thread 타입

쓰레드는 2가지의 쓰레드로 나눌 수 있다. **User Thread**와 **Kernel Thread** 이다.

**User Thread**는 **유저 레벨의 Thread 라이브러리를 통해 관리되는 Thread**이며, **Kernel Thread**는 **운영체제가 제공하고 직접 관리하는 Thread**이다.



#### Multi Thread Model

- Many to One model
- One to One model
- Many to Many model
- Two Level model



## Process 동기화

**Multi Thread 환경**에서는 **임계 구역 문제**가 발생한다. 따라서 우리는 **한 번에 한 쓰레드만 접근**할 수 있도록 **프로세스 동기화**가 필요하다.

**임계 구역 문제를 해결**하기 위해서는 **3가지**가 만족해야 한다.

#### 상호 배제(Mutual Exclosion)

오류가 일어나지 않기 위해서 공유 자원에 대한 업데이트는 한 순간에 오직 한 쓰레드만 진행할 수 있도록 하는 기법

#### 진행(Progress)

어느 쓰레드가 먼저 임계 구역에 들어갈 것인가에 대한 결정이 유한 시간 내에 일어나야 한다는 조건

#### 유한 대기(Bounded Waiting)

쓰레드가 임계 구역에 유한 시간 내에 접근해야 한다는 것을 의미. 일정 시간 내에 쓰레드가 들어가야 한다.



### 프로세스 동기화

#### Semaphore (세마포어)

동기화 문제를 해결하기 위한 소프트웨어 도구. **공유자원을 접근**하기 위해서 **S(semaphore)를 얻어야 하고** **접근이 끝나면** 다른 Task가 사용할 수 있도록 **S를 반환**하는 기술이다.

세마포어는 P(acquire), V(release)라는 두 개의 연산을 통해서 S를 접근한다. S는 키의 개수를 의미한다. S는 0 과 1, 혹은 양의 값을 갖는다.

세마포어는 운영체제가 관리한다.



#### Mutex (뮤텍스)

동기화 문제를 해결하기 위한 또 다른 소프트웨어 도구. 공유자원에 접근하기 위해 락을 얻고 접근이 끝나면 락을 해제해야 한다. 

뮤텍스는 0과 1만 존재하며 locking과 unlocking을 통해 뮤텍스를 조작한다.

뮤텍스는 프로세스 범위이며 프로그램으로 관리한다. 또한 소유가 가능하기 때문에 한 스레드가 소유하게 되면 다른 스레드가 해제할 수 없다.



## Deadlock (데드락)

**상호 배제**에 의해 나타나는 **문제점**으로 **둘 이상의 프로세스**들이 **자원을 점유한 상태**에서 서로 **다른 프로세스가 점유하고 있는 자원을 요구**하며 **무한정 기다리는 현상**을 의미.

결과적으로 서로 기다리기만 할 뿐 아무것도 완료되지 못함.

데드락(교착상태)가 일어나는 필요 조건은 4가지이다.

- **Mutual Exclusion (상호 배제)**: 동기화를 사용하기 위한 조건
- **Hold and wait (보유 및 대기)**: 프로세스가 자신이 가질 수 있는 자원은 가지고 있으면서 다른 자원이 오기를 기다리고 있는 것이다.
- **No Preemption (비선점)**: 임의의 프로세스가 자원을 할당 받은 상태에서 다른 프로세스는 이 자원을 뺏어서 사용할 수 없는 형태이다.
- **Circular Wait (순환 대기)**: 데드락이 선형이 아니라(두 개의 프로세스끼리) 원형을 이루게 됨을 의미. 이 조건은 꼭 필요한 조건은 아니다.

따라서 **데드락을 방지**하려면 **4가지 중 한 가지 이상을 불만족**시키면 된다.



### 데드락 핸들링

데드락을 다루는 방법에는 크게 3가지가 있다.

1. **Deadlock 현상 자체를 미연에 방지하는 방법**
   - 알고리즘을 사용하여 데드락이 발생하는 지 검사한다.
   - 오버헤드가 크다.
2. **Deadlock 상태를 허용하면서 그것을 복구하는 방법**
   - 현재 상태를 주기적으로 체크하면서 데드락 상태인지 확인한다. 확인되면 복구한다.
   - 이 또한 오버헤드가 크다.
3. **Deadlock 자체를 무시하고 발생하면 프로세스를 죽이는 방법**
   - 데드락을 허용하면서 발생한다면 문제가 있는 프로세스를 Kill한다.
   - 대부분의 운영체제가 이 방식을 사용한다.