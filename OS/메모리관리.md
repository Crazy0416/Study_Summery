# 메모리 관리

## 메모리 관리의 필요성

- 과거나 현재나 메모리 자원은 매우 중요하다. 과거에는 메모리 용량이 부족했고 현재는 메모리 용량이 크게 증가했어도 프로세스의 크기가 매우 크다. 따라서 메모리의 효율적인 관리 방법이 필요하다.
- 물리적으로 일일히 메모리를 관리하긴 힘들기 때문에 **가상 메모리**라는 개념을 사용해 메모리를 관리한다. (조금 나중에 설명)



## 메모리 관리를 배우기 전에 알아야 할 점

### Logical(Virtual) Address와 Physical Address

- **Logical(Virtual) Address**
  - CPU가 명령문을 실행함으로써 발생하는 메모리 주소
  - 프로세스 관점에서 사용하는 메모리 주소이다.
- **Physical Address**
  - 메모리의 실제 주소이다.
  - 물리 주소와 논리 주소는 서로 다를 수 있다.

### 독립적인 프로세스 메모리 공간

- 메모리에서 **프로세스의 시작위치를 저장하는 base register**와 **프로세스의 할당된 메모리의 크기인 Limit Register** 값을 이용해 프로세스들의 메모리 공간의 경계를 나눈다.
  - 따라서 프로세스마다 메모리 공간 침범을 막는다.
    ![독립된 프로세스 메모리 공간](https://raw.githubusercontent.com/Crazy0416/Study_Summery/master/OS/resources/memory_manage_1.png)
-  **주소 바인딩 시점**
  - **주소 바인딩**이란 프로세스가 접근해야 하는 값과 함수에 대한 주소가 정해지는 것.
    - 이 주소 바인딩이 시점에 따라 달라진다. 
  - 주소 바인딩 시점
    - 컴파일 시점 주소 바인딩
    - 로드 시점 주소 바인딩
    - 실행 시점 주소 바인딩



## 메모리 낭비 방지

- **동적 로딩(Dynamic Loading)** 
  - 프로세스의 모든 모듈들을 올리기에는 메모리 공간이 부족하다. 따라서 **해당 모듈이 필요하면 그때 그때 메모리에 로딩하는 방식이 동적 로딩**이다. 따라서 **프로그램 실행에 반드시 필요한 루틴/ 데이터만 적재하고 그 외에는 필요할 때마다 불러 쓰는 방식**이다.
- **동적 연결(Dynamic Linking)**
  - **여러 프로그램에 공통으로 사용되는 라이브러리를 관리하는 방법**이다. 매번 프로세스를 생성할 때마다 공통으로 사용되는 라이브러리를 메모리에 계속 적재하는 것은 메모리 낭비이다. 
    따라서 **라이브러리 루틴 연결을 실행 시까지 미루고 오직 하나의 라이브러리 루틴만 메모리에 적재한 뒤 다른 프로세스는 그 라이브러리를 참조**하면 메모리 공간을 절약할 수 있다.
- **스와핑(Swapping)**
  - 우선순위가 높거나 중요한 프로세스가 메모리에 올라가려 할 때 메모리 공간이 부족하면 **현재 메모리 위에 올라가 있는 프로세스 중 하나를 알고리즘을 사용해 고른 뒤 그 프로세스를 잠시 디스크에 저장**해 메모리 크기를 일시적으로 늘리는 방법.



## 프로세스 메모리 할당 방식

프로세스를 생성할 때 마구잡이로 메모리에 올리고 해제하다보면 메모리 중간 중간 할당되지 않은 빈 공간이 단편적으로 생긴다. 이를 **외부 단편화**라고 한다. 이를 해결하기 위해 **3가지의 연속 메모리 할당 방식**을 사용한다.

### 연속 메모리 할당 방식

#### 최초 적합(First Fit)

메모리를 순차적으로 탐색하여 제일 먼저 발견한 적절하게 들어갈 수 있는 곳을 찾아 프로세스를 적재하는 방식이다.

#### 최적 적합(Best Fit)

메모리를 탐색하여 메모리 공간 중에서 제일 적절하게 들어갈 수 있는 곳을 찾아 프로세스를 적재하는 방식이다.

#### 최악 적합(Worst Fit)

메모리에 넣는데 크기와 제일 안 맞는 공간(프로세스보다 큰 메모리 공간)에 프로세스를 적재하는 방식이다.

##### 속도

최초 적합이 제일 빠르게 할당됨

##### 효율성

최적 적합이 속도는 조금 떨어지지만 정확하게 맞는 위치에 들어가기 때문에 애매한 빈 공간을 창출할 일이 많이 없다.

하지만 연속 메모리 할당 방식을 사용해도 **외부 단편화로 인한 메모리 낭비가 1/3** 정도 발생한다. 이를 해결하기 위해 또 다른 방식인 Compaction이 존재한다.
**Compaction(압축)**은 프로세스들의 메모리 위치를 전부 한 곳으로 몰아 빈 공간을 하나로 만드는 방식이다. 하지만 이 프로세스를 한 데 모으는 작업은 메모리 공간에 접근할 때 잘못된 주소로 접근할 수 있기 때문에 상당히 제한적이다.

그래서 다른 방식이 생겼는데 **Paging(페이징)**과 **Segmentation(세그멘테이션)** 기법이다.



### Paging(페이징) 방식

#### 페이징이란?

프로세스의 **Logical Memory**를 조각**(페이지)**으로 나누어 그에 대응하는 **Physical Memory** 공간 조각**(프레임)**이 어디에 위치하는 지 목차와 같은 역할을 하는 **Page Table**에 저장을 한다.

여기서 **페이지**와 **프레임**의 **크기는 같고**, **Page Table의 인덱스 수**는 **Page의 수와 같다**!!

프로세스가 사용하는 **논리주소**는 CPU를 통해 **page table**에서 **물리 주소**로 바뀌어서 메모리에서 찾게 된다.



#### 보호 및 공유

- **보호**: 페이지 테이블에서 메모리에 대한 해킹을 할 수 없도록 r,w,x 비트를 두어 메모리 보호를 한다.
- **공유**: code 영역은 읽기만 가능하기 때문에 critical section 문제가 발생하지 않음. 따라서 이런 공유할 수 있는 부분을 페이지에 넣고 다른 프로세스와 공유할 수 있다.



![페이징 방법](https://raw.githubusercontent.com/Crazy0416/Study_Summery/master/OS/resources/memory_manage_2.png)

만약 **50번지라는 논리 주소**를 **물리주소**로 바꾸고 싶다고 하자. 이때 **페이지의 크기는 16바이트**다.

- 50번지 => **110010**(이진수) 
- 페이지 크기 **16바이트**이므로 **하위 4비트는 d**가 되고 **앞의 두 비트**가 **페이지 인덱스를 나타내는 p**가 된다.
- **11(이진수) => 3(십진수)** 이므로 페이지 테이블에서 **3의 위치에 있는 값 f**를 가지고 오면 **f+d가 물리 주소**가 된다.
- 만약 f가 8이면 8(십진수) => 1000(이진수). 따라서 물리 주소는 1000(f) + 0010(d) => **10000010** => **130(십진수)**번지가 된다.



#### 페이징의 문제점

페이징 또한 문제점이 있다. 바로 **내부 단편화**이다. 

페이지는 프로세스를 특정 단위인 페이지 단위로 나누게 되는데, 이때 프로세스의 크기가 페이지 크기의 배수가 아니면 아무래도 페이지에 빈 공간이 생긴다. 물론 이는 매우 작은 값으로 외부 단편화에 비해 메모리 낭비는 미비하다.



### Segmentation(세그멘테이션) 방식

#### 세그멘테이션이란??

세그멘테이션은 **프로세스**를 **세그먼트의 집합**으로 생각한다. 프로세스는 동작하려면 기본적으로 코드, 데이터, 스택 세가지의 세그먼트는 항상 가지고 있다. 또한 main 함수, 다른 함수 등등 많은 논리적 내용의 단위들이 많은데 이처럼 **논리적 기준으로 자르기 때문에 세그먼트들의 크기는 일반적으로 같지 않다**.

또한  페이징은 페이지가 전부 같은 크기이지만 **세그멘테이션은 세그먼트들의 크기가 다 다르기 때문에** **세그먼트 테이블**은 해당 세그먼트의 **시작점 base**와 **끝을 알리는 limit**을 가지고 있어야 한다.

그 외에 것들은 페이징과 다를 바가 없다.

세그먼트를 의미있는 단위로 나누게 되면 **보호와 공유**를 하는 측면에서 **이점**을 가질 수 있게 된다.

![세그멘테이션 방법](https://raw.githubusercontent.com/Crazy0416/Study_Summery/master/OS/resources/memory_manage_3.png)



#### 세그멘테이션의 문제점

크기가 고정되어 있지 않고 가변적이기 때문에 외부 단편화가 올 수 있다.



#### 세그멘테이션과 페이징의 공유 코드

세그멘테이션이 논리적으로 구분 되어 있기 때문에 필요한 부분의 범위를 딱 정할 수 있으므로 페이징보다 **더 나은 보호 및 공유의 기능**을 수행한다.



## 가상 메모리

### 가상 메모리란?

가상 메모리를 사용한다면 **당장 실행에 필요한 부분만 실제 메모리에 올려서 실행**하게 된다.

즉 **프로세스가 구동되기에 필요한 부분**만 **메모리에 올림**으로써 메인 메모리에 올라가는 프로세스의 크기를 줄여 **메모리를 효율적으로 사용**한다. (동적 로딩과 비슷)



#### 요구 페이징(Demand Paging)

먼저 **페이징 과정**을 거처 페이지 단위로 프로세스를 자른다. 그 후 **실행에 필요한 페이지만 메모리에 적재**하는 방식을 **요구 페이징 방식**이라고 한다.

##### Backing Store

swap divice**로 하드웨어의 부분인데 **페이지를 임시로 보관하는 공간

#### 요구 페이징의 페이지 구분

요구 페이징은 프로세스의 이미지를 **Backing Store**에 저장한다. 

이때 backing store를 사용하면 **페이지**가 **메모리에 올라와 있는 것**도 있고, **backing store에 있는 것**도 있다. 이를 구분하기 위한 **valid bit 필드**(0과 1)를 **page table(페이지 테이블)**에 추가한다.



##### Page Fault

당장 실행해야 되는 **명령어가 메모리에 없다면** Backing Store에서 가져와야 한다. 이를 수행하기 위해서 **CPU**는 잠시 하는 일을 멈추고 운영체제가 나서서 **Backing Store를 뒤져 해당 페이지를 메모리에 적재**하게 된다. 그 후에 valid 비트를 올라와 있다고 바꿔준다. 이를 **페이지 결함, Page Fault**라고 부른다.



#### 요구 페이징의 두 가지 종류

- **pure demand paging**
  - 처음부터 모든 페이지를 적재시키지 않고 CPU가 요구할 때 메모리에 적재
- **prepaging**
  - 우선 필요할 것 같은 페이지를 적재시키고 필요할 때 다른 페이지를 적재



#### 유효 접근 시간

평균적으로 **CPU**가 요구할 때 **메모리를 통해 읽혀지는 시간**



#### 지역성의 원리

**CPU**가 **참조하는 주소**가 지역에 **모여져 있다는 의미**이다.



## 페이지 교체

**요구 페이징**은 요구되는 페이지를 backing store에 가져와 메인 메모리에 적재(loading)한다. 하지만 **메인 메모리가 가득 차게 되면** 메인 메모리에 있는 **특정 페이지를 내보내야할 필요**가 있다. 그 자리에 **필요한 다른 페이지를 올려야 한다.** 

이를 **페이지 교체**라고 한다.

#### page out

backing store로 페이지를 몰아내는 것

#### page in

빈 공간으로 페이지를 가져오는 것



### 페이지 교체 알고리즘



#### FIFO (First In First Out)

메모리에 올라온 페이지를 먼저 내보낸다는 알고리즘이다.

#### OPT(Optimal)

가장 사용하지 않을 페이지를 가장 우선적으로 내려 보내는 알고리즘이다.

하지만 이는 미래를 알 수 없는 조건에 의해 실질적으로 수행하기에는 큰 어려움이 있다.

#### LRU(Least Recently Used)

최근에 사용하지 않은 페이지를 가장 먼저 내려 보내는 알고리즘이다.

##### Global 교체

메모리상의 모든 프로세스 페이지에 대해 교체를 하는 방식. 프로세스 전체를 swap

##### Local 교체

메모리상의 자기 프로세스 페이지에서만 교체를 하는 방식. 프로세스 A의 a 페이지와 b 페이지를 swap.





## 프레임 할당

### Thrashing (쓰레씽)

메인 메모리에 프로세스 수가 많아지면 당연히 CPU의 계산량도 많아진다. 허나 **프로세스가 너무 많아지면 어느 순간부터 CPU의 사용량이 줄어들기 시작한다.** 프로세스 수가 많아지면 프로세스 당 할당 받는 페이지 수가 적어 **page fault**가 일어나기 쉽기 때문에 CPU가 동작하지 못하는 시간이 늘어나기 때문이다. 이를 **Thrashing(쓰레씽)**이라고 한다. Thrashing을 극복하는 방법은 local 교체를 사용하는 방식이 좋다. 혹은 프로세스 당 충분한 수의 메모리를 할당하는 것도 방법이다.



프로세스 당 충분한 수의 메모리를 할당한다는 것은 적절한 프레임을 할당하는 것과 같다고 할 수 있다. 

그래서 프레임을 할당하는 방법은 2가지 방법이 있다.

### 프레임 할당

#### 균등 할당(equal allocation)

각 프로세스 당 동일한 프레임을 할당하는 방식. ex) 각 프로세스에 25개의 프레임을 할당

#### 비례 할당(proportional allocation)

프로세스 크기에 따라 비례적으로 나누는 방식



#### 우선순위 할당(Priority allocation)

우선순위가 높은 프로세스에게 더 많은 프레임을 할당해주는 방식



참고: 

- https://copycode.tistory.com/88?category=740133
- https://baked-corn.tistory.com/15

